# Распределенные вычисления. Лабораторная работа 1. Этап 2

## How to build

### Requirements

- \*NIX system
- clang (https://clang.llvm.org/)
- make

### Build command

```shell
make all
```

Artifacts:

- output executable in `./build/pa3.o`
- archive with sources in `./build/pa3.tar.gz`

### Usage

```shell
Usage: pa3.o [OPTION...]
Distributed computing lab1 step1 -- a distributed program communicates with
pipes

  -d, --debug                Enable debug messages
  -i, --debug-ipc            Enable debug messages for IPC
  -p, --process=NUMBER OF PROCESSES
                             Amount of processes (2-15)
  -t, --debug-time           Enable debug messages for TIME
  -w, --debug-worker         Enable debug messages for WORKER
  -?, --help                 Give this help list
      --usage                Give a short usage message
  -V, --version              Print program version

Mandatory or optional arguments to long options are also mandatory or optional
for any corresponding short options.

Report bugs to zhenyagurin@gmail.com.
```

**Example:** Run with 3 child processes and start balance 30$, 40$ and 50$

```shell
./pa3.o -p 3 30 40 50
```

## Скалярное время Лэмпорта

### Введение

В распределенных системах отсутствуют глобальные часы, отсчитывающие общее
для всех процессов время, и к показаниям которых процессы могли бы получать
мгновенный доступ. Существуют различные способы синхронизации физических часов:
радио часы (WWV), протокол NTP и его производные — однако максимальная точность
синхронизации составляет порядка нескольких миллисекунд, что для ряда приложений
недостаточно.

Для правильной работы распределенных приложений необходимо определить
отношение «произошло раньше», связывающее события процессов между собой, не
опираясь на понятие единого физического времени. Поэтому распределенные приложения
используют различные варианты логического времени.

### Исходные данные

- Число N процессов, составляющих распределенную банковскую систему;
- Начальные балансы S для каждого из счетов (один процесс — один счет),
  где N и S — целые числа. При автоматической проверке N ∈ \[2; 10\], S ∈ \[1; 99\].

### Постановка задачи

За основу банковской системы необходимо взять модель распределенной системы,
описанную в условии к этапу №1. Разделяют два типа процессов, составляющих
банковскую систему:

- процессы, принимающие запросы от клиентов (тип `«К»`);
- процессы, отвечающие за обслуживание счетов (тип `«С»`).

В данном этапе лабораторной работе используется один процесс типа `«К»` и N – 1
процессов типа «C». Каждый процесс имеет собственные логические часы. Процессы
обмениваются сообщениями в асинхронном режиме.

Процесс `«К»` на основе запросов клиента формирует запросы к соответствующим
процессам `«С»`. Поддерживаются следующие операции:

- перевод денег между счетами;
- получение информации об истории изменения баланса.

При переводе денег процесс `«K»` отправляет сообщение процессу `«С_src»`, с которого
осуществляется списание. Процесс `«C_src»` после выполнения требуемых операций
пересылает исходное сообщение процессу `«С_dst»`. Процесс `«С_dst»` после выполнения всех
необходимых действий отправляет процессу `«K»` подтверждение о выполнении операции.
Предполагается, что используются корректные запросы на перевод и каналы надежные,
поэтому другие подтверждения о выполнении операций не требуются.

### Задание

Используя топологию распределенной системы и библиотеку межпроцессного
взаимодействия (IPC) из первого этапа лабораторной работы, необходимо реализовать
банковскую систему, описанную выше.

Во время выполнения программы осуществляются переводы денег между счетами.
При завершении на экран выводится таблица с информацией о балансе каждого счета и
полной сумме денег, находящихся на всех счетах, в каждый момент времени `t ∈ 0, 1, …, T`.
Последняя отметка времени T определяется на момент завершения каждого из процессов
`«C»` (при получении соответствующего сообщения от процесса `«К»`, см. далее),
`T ≤ MAX_T`.

При запуске программы, как и раньше, указывается число дочерних процессов в
полносвязной топологии. Последние X параметров задают начальные балансы для
каждого из счетов. Например, следующая команда:

```shell
./pa3 -p 3 10 20 30
```

означает, что в банковской системе три счета (точнее три филиала, каждый из
которых обслуживает всего один счет) с идентификаторами 1, 2, 3 и с начальными
балансами $10, $20, $30 соответственно.

В реализации банковской системы необходимо использовать скалярное время
Лэмпорта. Для обмена отметками времени процессы должны использовать поле
`s_local_time` структуры `MessageHeader`, которое должно содержать показания часов
процесса-отправителя на момент отправки сообщения. Получение текущей отметки
времени осуществляется посредством вызова функции `get_lamport_time()`, которую
необходимо реализовать.

Логические часы инициализируются нулем. Считать, что у процессов отсутствуют
внутренние события, т.е. линейному упорядочиванию подлежат только события отправки
и получения сообщений. Перед выполнением любого события процесс увеличивает
показания своих логических часов на единицу. Так при отправке сообщения показания
часов сначала увеличиваются, а уже потом в сообщение вкладывается отметка времени.
Отправка группового сообщения посредством функции `send_multicast()` продвигает время
на единицу вне зависимости от числа отправленных сообщений. В случае, когда два
события имеют одинаковые временные метки, линейный порядок определяется на основе
идентификаторов процессов, в которых произошли данные события.

Процесс `«К»` реализуется на основе родительского процесса, процессы `«С»` — на
основе дочерних процессов из этапа №1. После того, как получены сообщения `STARTED`
от всех процессов `«С»`, процесс `«К»` должен вызвать функцию bank_robbery(), которая
выполняет ряд переводов денег между произвольными процессами `«С»` посредством
вызовов функции `transfer()`. Перевод описывает структура `TransferOrder`, передаваемая
сообщением типа `TRANSFER`. При выполнении перевода процесс `«К»` отправляет
сообщение `TRANSFER` процессу `«C_src»`, после чего переходит в режим ожидания
подтверждения (пустое сообщение типа ACK) процессом «Сdst» получения перевода.
Переводы могут быть инициированы только процессом `«К»`.

После выполнения функции `bank_robbery()` процесс `«К»` отправляет сообщение
STOP всем процессам `«С»` и дожидается получения сообщения DONE от всех дочерних
процессов. После этого процесс `«К»` должен получить от каждого процесса `«С»`
сообщение `BALANCE_HISTORY`, содержащее структуру `BalanceHistory`. Структуры
`BalanceHistory` от всех процессов `«С»` агрегируются в структуру AllHistory, которая
должна быть использована в качестве аргумента функции `print_history()` перед
завершением родительского процесса. Функция `print_history()` реализуется библиотекой,
поставляемой вместе с заданием.

«Полезной» работой процесса `«С»` является ожидание и обработка сообщений двух
типов: `TRANSFER` и STOP. При получении сообщения `TRANSFER` процесс `«C_src»` после
выполнения всех необходимых операций пересылает это сообщение процессу `«C_dst»`.
Процесс `«C_dst»` обрабатывает сообщение и отправляет сообщение ACK процессу `«К»`. При
этом каждый процесс `«С»` должен хранить в структуре типа `BalanceHistory` информацию о
состоянии своего баланса `BalanceState` в каждый момент времени t. Обратите внимание,
что если в момент времени t=1 баланс процесса равен $10, а в t=3 ему пришел перевод в
$5, то в t=2 следует указать баланс $10. Семантика структур `BalanceHistory` и `BalanceState`
подробно описана в заголовочном файле banking.h.

Также при подсчете полной суммы денег в каждый момент времени необходимо
учитывать состояние каналов между процессами, т.е. сохранять информацию о переводах,
которые были отправлены, но еще не были получены. Для этого необходимо заполнять
поле `s_balance_pending_in` структуры `BalanceState`. Обратите внимание, что ввиду
синхронности протокола данная задача является упрощенным вариантом задачи подсчета
полной суммы, рассмотренной на лекции.

При получении сообщения STOP процесс `«С»` переходит к выполнению третьей
фазы. Во время выполнения третьей фазы процесс `«С»` может получать сообщения
«`TRANSFER`» от других процессов `«С»`, при этом гарантируется, что после отправки
сообщения STOP процесс `«К»` не выполняет новых переводов. После получения
сообщений DONE от всех остальных дочерних процессов и перед завершением процесс
`«С»` отправляет процессу `«К»` сообщение `BALANCE_HISTORY`, содержащее структуру
`BalanceHistory`.

В дополнение к событиям из предыдущего этапа (строки форматирования изменены)
для процессов типа `«С»` добавлено два новых события:
• процесс отправил перевод на другой счет (`log_transfer_out_fmt`);
• процесс получил перевод с другого счета (`log_transfer_in_fmt`).

Для реализации асинхронного обмена сообщениями необходимо использовать
неблокирующие функции `read()` и `write()`. Как и в предыдущем этапе, в реализации
запрещается использовать многопоточность: один процесс — один поток. Кроме того,
нельзя использовать разделяемую память, примитивы синхронизации (семафоры и т.п.),
функции `select()` и `poll()`. Логирование (events.log, pipes.log и терминал), как и в
предыдущем задании.

### Требования к реализации и среда выполнения

Реализацию необходимо выполнить на языке программирования Си
с использованием предоставленных заголовочных файлов и библиотеки из архива pa2345_starter_code.tar.gz.
Архив содержит следующие файлы:

- `ipc.h` -- объявления структур данных
  и функций для организации межпроцессного взаимодействия.
  Объявленные функции необходимо реализовать;
- `banking.h` -- объявления структур данных, констант и функций, связанных с
  банковскими операциями. Часть функций реализовано преподавателем;
- `pa2345.h` --  форматы строк для логирования;
- `bank_robbery.c` -- набор вызовов `transfer()` для тестирования реализации;
- `libruntime.so` -- библиотека, реализующая вспомогательные функции, в частности
  `print_history()`. Инструкции по использованию см. ниже;

Заголовочные файлы содержат большое число важных комментариев, пояснений и
рекомендаций. Запрещается их модификация: при автоматической проверке они
заменяются на оригинальные.

Файл `bank_robbery.c` содержит функцию `bank_robbery()`. Версия `bank_robbery.c` из
архива отличается от той, что используется при проверке задания.
Для использования `libruntime.so` необходимо определить следующие переменные
программного окружения:

```shell
export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:/path/to/pa3/dir";
### пустая строка
LD_PRELOAD=/full/path/to/libruntime.so ./pa3 –p 2 10 20
```

Использование неблокирующих `read()` и `write()` может потребовать дополнительных
изменений в реализации IPC. Новая версия библиотеки IPC должна быть совместима с
версией для предыдущего этапа лабораторной работы.
Работа присылается в виде архива с именем `pa3.tar.gz`, содержащим каталог `pa3`. Все
файлы с исходным кодом и заголовки должны находиться в корне этого каталога. Среда
выполнения — `Linux (Ubuntu 14.04, clang-3.5)`. При автоматической проверке
используется следующая команда: `clang -std=c99 -Wall -pedantic *.c –L. -lruntime`. При
наличии варнингов работа не принимается. При успешном выполнении запущенные
процессы не должны использовать stderr, код завершения программы должен быть равен 0.
